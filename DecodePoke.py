from eth_abi import decode
from eth_abi.packed import encode_packed
from eth_utils import decode_hex, keccak, to_bytes, to_checksum_address
from eth_keys import keys
from datetime import datetime, timezone

# Input data (with '0x' prefix)
input_data = "0x89bbb8b200000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000260000000000000000000000000000000000000000000000000000000000000042000000000000000000000000000000000000000000000000000000000000005e000000000000000000000000000000000000000000000000000000000000007a0000000000000000000000000000000000000000000000000000000000000000d00000000000000000000000000000000000000000000129e34fb5a93df24000000000000000000000000000000000000000000000000129e481055cae54d800000000000000000000000000000000000000000000000129e48692728fcb0000000000000000000000000000000000000000000000000129e48692728fcb0000000000000000000000000000000000000000000000000129e8247f8110611000000000000000000000000000000000000000000000000129ef2e63d92465c800000000000000000000000000000000000000000000000129f85b9f38421fe80000000000000000000000000000000000000000000000012a0af9cf34a29c100000000000000000000000000000000000000000000000012a11abfe6632bc500000000000000000000000000000000000000000000000012a39393a4c9c99500000000000000000000000000000000000000000000000012a5b104c493f17280000000000000000000000000000000000000000000000012a7b2fb84dbaa0a00000000000000000000000000000000000000000000000012a9ac224c00aa420000000000000000000000000000000000000000000000000000000000000000000d0000000000000000000000000000000000000000000000000000000067329dc70000000000000000000000000000000000000000000000000000000067329da70000000000000000000000000000000000000000000000000000000067329da70000000000000000000000000000000000000000000000000000000067329daa0000000000000000000000000000000000000000000000000000000067329dc90000000000000000000000000000000000000000000000000000000067329dc90000000000000000000000000000000000000000000000000000000067329dcf0000000000000000000000000000000000000000000000000000000067329da30000000000000000000000000000000000000000000000000000000067329dc20000000000000000000000000000000000000000000000000000000067329d6d0000000000000000000000000000000000000000000000000000000067329d9c0000000000000000000000000000000000000000000000000000000067329d920000000000000000000000000000000000000000000000000000000067329d77000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000000d4aa411c0a8436ac17a4d87357ae47ff77bcc03bfa87a08418776833ba65ae9f461f02505e808904a33ab812418d665d0235919a8c61f197e3ddae8f7bda520b54bd2193bb00ba413e5d20597bde5bdf4dcedea0fc0e101492f8827631b40591721b5623a288f43614cfbf107c21f0e4105179d5b37dd1eb40a2f3e17d13c66b9fe97cb0cf215e9d8dd950820917f58bdf07ce0841f8def3291c71130770fec924dd15398c0a32eac0cd6b22303eababe7639bbc4d05502f88bebed4d381be6a66df8c7cdfb480ae196785585b100fb63f4c2ad0ed8bc20a29182e7787b9d23b4ce6242c2d06fba839026765bf57bfdaa3d6ba22b22e751a96efd7401ecda7ee785842ef7fb3e08dbe0088c8bdcf3002df23462b3e366d106d734dbb337a18196a23c76f36e80b4de61144197ea93c95b60cc9e09e9c619e9dc45a1312b5a9f43d049c568df439f5171c08691f671bce08c954210a4a78732ba69e0e007eff46c1c616edda89ecdb708b81bf6dbd7903d94f613a8fc1d16750709737d0d10358dfb4a8f8c2f318f03eb39aec3827e0fdce2f638fbfe9efad12b8d135b24ed025d000000000000000000000000000000000000000000000000000000000000000d52b005e8d72f3a94ea96670e1f38ff0e2086ac4ea36e379005346a7f0e6a787025b7b26ca43d6cb4744c1166e51cc1d75791f4eede7514b2b101f84472ac2ff04a69901a335ecc5d7906df12fcb0e5f118da58bda57a3e98e7c74338dbaaff3130cc8994dde6c3f57dcd3c54743973c9c65707a14ad4e5f7484c40bb2a2f82c93e55553929247f5be3f2eddaa43bf57a4e165194d8a6f535648fd9fdb6b5407454faabd901b58f68be9ae8fd25a5ad69fc219a280be933c1aab40f7cf545752730ab75066812a97ecda7ec872d24acc56cb40534ab49be7b21249168285d1bf728730a656ba42b54335cb31af5f2b6e661d036f0c6f6aee8ce20c8b40858d7972977f4375bb5ce4a78af6d66d85ea5850c24f16ce5102b57cfd74d58683588565e1c4242e2b348be581f5affda3a870a15f4b4e3387c46a74c25b6371c793e82758a10beb101469bc9f667effe179abb1bae8abd0d727b870e3fd3f0c447ca6107b8ff32e491052589535d03aad3b584880df4c3ed2bd01a2831b148463b4ace056df9a8378b05077a3ccfea2e760104f0ab838988345e3fdf6ff35a60cfb568"

# Remove the function selector (first 10 characters: '0x' + 8 characters)
data = input_data[10:]

# Convert hex string to bytes
data_bytes = bytes.fromhex(data)

# Define the types of the parameters
types = [
    'uint256[]',  # val
    'uint256[]',  # age
    'uint8[]',    # v
    'bytes32[]',  # r
    'bytes32[]'   # s
]

# Decode the data
decoded = decode(types, data_bytes)

# Access each parameter
val = decoded[0]
age = decoded[1]
v = decoded[2]
r = decoded[3]
s = decoded[4]

# Print the decoded parameters with decimals and converted timestamps
print("Decoded Parameters:")
print("===================")
print(f"'val' (uint256[]):")
for idx, value in enumerate(val):
    # Convert to decimal by dividing by 1e18
    price = value / 1e18
    print(f"  [{idx}]: {price} (BTC/USD)")

print(f"\n'age' (uint256[]):")
for idx, timestamp in enumerate(age):
    dt = datetime.fromtimestamp(timestamp, timezone.utc)
    print(f"  [{idx}]: {timestamp} ({dt.strftime('%Y-%m-%d %H:%M:%S %Z')})")

print(f"\n'v' (uint8[]):")
for idx, value in enumerate(v):
    print(f"  [{idx}]: {value}")

print(f"\n'r' (bytes32[]):")
for idx, value in enumerate(r):
    print(f"  [{idx}]: 0x{value.hex()}")

print(f"\n's' (bytes32[]):")
for idx, value in enumerate(s):
    print(f"  [{idx}]: 0x{value.hex()}")

# Define the 'wat' value as in the contract
wat = b'BTCUSD'

# Now, verify each signature
print("\nRecovered Addresses:")
print("====================")
for idx in range(len(val)):
    val_i = int(val[idx])
    age_i = int(age[idx])
    v_i = int(v[idx])
    r_i = r[idx]
    s_i = s[idx]

    # Adjust v_i to be 0 or 1
    if v_i >= 27:
        v_i_adj = v_i - 27
    else:
        v_i_adj = v_i

    # ABI-encode the values using encode_packed
    encoded_message = encode_packed(['uint256', 'uint256', 'bytes32'], [val_i, age_i, wat])

    # Hash the encoded message
    message_hash = keccak(encoded_message)

    # Prefix the message as per EIP-191
    prefix = b"\x19Ethereum Signed Message:\n32"
    prefixed_hash = keccak(prefix + message_hash)

    # Create a Signature object
    signature = keys.Signature(vrs=(v_i_adj, int.from_bytes(r_i, byteorder='big'), int.from_bytes(s_i, byteorder='big')))

    # Recover the public key
    public_key = signature.recover_public_key_from_msg_hash(prefixed_hash)

    # Get the Ethereum address
    address = public_key.to_checksum_address()
    print(f"  [{idx}]: {address}")